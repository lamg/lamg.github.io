<!DOCTYPE html><html lang="en" class="css-267185508"><head><meta charset="UTF-8" /><title>LAMG</title><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script><script>hljs.highlightAll();</script></head><body><h1>Fixed points</h1>
<p>Let's take a look at a common implementation of a function for calculating Fibonacci numbers:</p>
<pre><code class="language-fsharp">let fibonacci0 n =

  let mutable i, a, b = 0, 0, 1



  while n <> i do

    let next = a + b

    a <- b

    b <- next

    i <- i+1

    

  a



fibonacci0 10</code></pre><p>Most people think since functional programing discourages mutation, that means tying their hands and being useless. However, there's a communication failure here. Functional programming is valuable, not because discourages mutation, but because it encourages structured programming and composability.</p>
<p>The above function contains one of those patterns that appear everywhere, and functional programming can help you to recognize and reuse it more than imperative programming. Let's take a look at the <code>power</code> function and how it allows to implement Fibonacci:</p>
<pre><code class="language-fsharp">let rec power (f: 'a -> 'a) (initial: 'a, n: int) =

  if n = 0 then initial else power f (f initial, n - 1)



let fibonacci1 n = power (fun (a, b) -> (b, a + b)) ((0, 1), n) |> fst</code></pre><p>Now you can see how <code>fibonacci1</code> is verbose in those aspects essential to Fibonacci: the initial state and how it transitions to the next. The rest is left to the <code>power</code> function.</p>
<p>Another thing <code>while</code> loops help us to find are <em>fixed points</em>, i.e. for a function <code>f</code> a value <code>c</code> that holds <code>f c = c</code>. But this pattern can be disentangled from <code>while</code> loops as well:</p>
<pre><code class="language-fsharp">let fixedPoint (f: 'a -> 'a) (initial: 'a) =

  let rec loop (prev: 'a) (current: 'a) =

    if prev = current then prev else loop current (f current)



  loop initial (f initial)</code></pre><p><a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD472.html">Euclid's Algorithm for calculating the Greatest Common Divisor between two positive integers</a> relies on finding a fixed point:</p>
<pre><code class="language-fsharp">let gcd0 (a:int, b:int) =

  let mutable x = a

  let mutable y = b

  while x <> y do

    if x > y then x <- x - y else y <- y - x

  

  x



gcd0 (12,8)</code></pre><p>Now, relying on our <code>fixedPoint</code> function we get:</p>
<pre><code class="language-fsharp">let step (x: int, y: int) =

  if x > y then x - y, y

  else if x < y then x, y - x

  else x, y



let gcd1 = fixedPoint step >> fst



gcd1 (12, 8)</code></pre><p>This time we discover there's a fixed point when dividing successive elements of the Fibonacci sequence. That number is known as <a href="https://en.wikipedia.org/wiki/Golden_ratio">Golden Ratio</a>.</p>
<pre><code class="language-fsharp">let fibonacci = Seq.unfold (fun (a, b) -> Some(a, (b, a + b))) (0, 1)



let fixedPointSeq (xs: 'a seq) = xs |> Seq.pairwise |> Seq.find (fun (a,b) -> a = b) |> fst



fibonacci |> Seq.pairwise |> Seq.map (fun (a,b) -> double b / double a ) |> fixedPointSeq</code></pre><p>Functions <code>power</code> and <code>fixedPoint</code> are inspired by the <a href="https://www.aplwiki.com/wiki/Power_(operator)">power operator in APL (‚ç£)</a></p>
</body></html>
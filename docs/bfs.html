<!DOCTYPE html><html lang="en" class="css-267185508"><head><meta charset="UTF-8" /><title>LAMG</title><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script><script>hljs.highlightAll();</script></head><body><h1>Revisiting BFS</h1>
<h5>What is BFS</h5>
<ul>
<li><p>BFS is a way of creating a sequence with all elements of a tree or graph</p>
</li>
<li><p>It consists in returning all elements with depth N, and then the elements with depth N+1, until elements are over</p>
</li>
<li><p>The initial depth is 0</p>
</li>
</ul>
<h5>The common solution</h5>
<ul>
<li><p>The typical imperative implementation of BFS relies on a queue</p>
</li>
<li><p>The current element is pulled out of the queue, and its children are pushed in</p>
</li>
</ul>
<h5>Questioning the common solution</h5>
<ul>
<li><p>The relation between the queue, the way it works, and the BFS definition is not clear</p>
</li>
<li><p>Is it possible to rely on pure functional data structures instead of mutation?</p>
</li>
</ul>
<h5>First discovery</h5>
<ul>
<li><p>The queue in the imperative solution is divided in two parts: <code>| children with depth N | children with depth N+1|</code></p>
</li>
<li><p>Now is clear what we do is returning children in the same level, and meanwhile conveniently recording and postponing children in the next level</p>
</li>
<li><p>We could have separate lists for children in different levels</p>
</li>
<li><p>We could annotate each level with its corresponding number, so we can filter later which levels do we need</p>
</li>
</ul>
<h5>First restriction</h5>
<ul>
<li>BFS in a graph requires to mark which nodes we have visited, while in a tree we don't,</li>
</ul>
<p>since in the latter case there's no possibility to create an infinite loop</p>
<ul>
<li>the function returning the children can take care independently of marking or not, depending on wether is a graph or a tree.</li>
</ul>
<p>That way the BFS implementation can be delivered from that concern, and thus is cleaner and more general.</p>
<h5>Second restriction</h5>
<ul>
<li>In functional programming instead of representing mutation in a block of code, we create a new instance of it</li>
</ul>
<p>substituting the old value by the new one.</p>
<ul>
<li>You can see the difference in comparing the following two blocks of code:</li>
</ul>
<pre><code class="language-csharp">
using System;



int[] MoveFromTo() {

    var from = new List&lt;int&gt;(new int[] { 1, 2, 3 });

    var to = new List&lt;int&gt;();

    while (from.Count &gt; 0) {

        to.Add(from[0]);

        from.RemoveAt(0);

    }

    return to.ToArray();

}

</code></pre>
<pre><code class="language-fsharp">
let moveFromTo () =

    let rec loop from to' =

        match from with

        | [] -&gt; (from, to')

        | x::xs -&gt; 

            // here we replace to' by x::to' in a new instance of loop

            loop xs (x::to')

    

    let from = [1; 2 ;3]

    let to' = []

    loop from to'

</code></pre>
<h3>How the implementation works</h3>
<ul>
<li><p><code>GetChildren</code> is our generic way of getting children from whatever nested structure we are dealing with (trees, graphs)</p>
</li>
<li><p>Along with the list of children it returns and instance of itself. This is needed because is the functional way of updating the collection where we store visited nodes.</p>
</li>
<li><p>Our <code>List.fold</code> processes each element <code>x</code> in <code>level</code>. In each iteration of it needs an updated <code>GetChildren</code> instance, which stores the visited nodes. You can see in the function passed as parameter how <code>xs</code> is replaced by <code>xs @ ys</code> and <code>gc</code> for <code>newGc</code>, for the next iteration.</p>
</li>
<li><p>Once the fold finishes we have in <code>nextLevel</code> all the nodes of level <code>n+1</code>. Since <code>nextLevel</code> is the replacement for <code>level</code> and our <code>bfs</code> function operates on particular level instances, then is time to call <code>bfs</code> with <code>nextLevel</code>. In case <code>nextLevel</code> is empty, we return the empty sequence and stop the recursive calls.</p>
</li>
</ul>
<pre><code class="language-fsharp">type GetChildren<'a> = { get: 'a -> (GetChildren<'a> * 'a list) }



let rec bfs (gc: GetChildren<'a>, n: int, level: 'a list) =

  seq {

    yield (n, level)



    let nextLevel =

      level

      |> List.fold

        (fun (gc, xs) x ->

          let newGc, ys = gc.get x

          (newGc, xs @ ys)

        )



        (gc, []) // initial state

        

    yield! 

        match nextLevel with

        | _, [] -> Seq.empty

        | (chl, nl) -> bfs  (chl, n+1, nl)

  }
</code></pre><h5>Testing the implementation with a graph</h5>
<pre><code class="language-fsharp">type Graph<'a when 'a: comparison> = Map<'a, List<'a>>



let graphChildren (g: Graph<'a>) =

  let rec children visited =

    { get =

        fun x ->

          if Set.contains x visited then

            // x is already visited, no need to mark it as visited

            (children visited, [])

          else

            let newChildren = Set.add x visited |> children



            match Map.tryFind x g with

            | Some xs -> (newChildren, xs)

            | None -> (newChildren, []) }



  children Set.empty



let g = Map [ 1, [ 2; 3; 4 ]; 2, [ 5; 6 ]; 3, [ 7; 8 ]; 4, [ 9; 10 ] ]



bfs (graphChildren g, 0, [ 1 ]) |> Seq.iter (printfn "%A")</code></pre><h5>Testing the implementation with a tree</h5>
<p>In a tree by visiting a node there's no way of going back to it, since there are no cycles. Keeping that in mind,</p>
<p>we can rely on a sequence of children to be consumed by <code>bfs</code>. As long as we put children in the order <code>bfs</code> expects them, the implementation will be correct.</p>
<p>Example:</p>
<p>We know if <code>bfs</code> gets the children of node <code>X</code>, then after that it will ask for children of node <code>X+1</code>, where <code>X</code> and <code>X+1</code> are consecutive nodes in the same level.</p>
<pre><code class="language-fsharp">type Tree<'a> = Node of 'a * Tree<'a> list



let rec childrenSeq (Node(_, xs)) =

  seq {

    match xs with

    | [] -> ()

    | _ ->

      let nodeValues = xs |> List.map (fun (Node(x, _)) -> x)

      yield nodeValues



    for x in xs do

      yield! childrenSeq x

  }



let treeChildren (t: Tree<'a>) =

  let chs = childrenSeq t |> Seq.toList



  let rec loop (chs: ('a list) list) =

    { get =

        fun _ ->

          match chs with

          | [] -> (loop [], [])

          | head::tail -> (loop tail, head) }



  loop chs



let t =

  Node(

    1,

    [ Node(2, [ Node(5, []); Node(6, []) ])

      Node(3, [ Node(7, []); Node(8, []) ])

      Node(4, [ Node(9, []); Node(10, []) ]) ]

  )



bfs (treeChildren t, 0, [ 1 ]) |> Seq.iter (printfn "%A")</code></pre></body></html>
[{"uri":"/lamg.github.io/fixed_points.html","title":"Fixed points\n","content":"Fixed points\nLet\u0027s take a look at a common implementation of a function for calculating Fibonacci numbers:\nlet fibonacci0 n =\n  let mutable i, a, b = 0, 0, 1\n\n  while n \u0026lt;\u0026gt; i do\n    let next = a \u002B b\n    a \u0026lt;- b\n    b \u0026lt;- next\n    i \u0026lt;- i\u002B1\n    \n  a\n\nfibonacci0 10\n\n55\n.dni-code-hint {\n    font-style: italic;\n    overflow: hidden;\n    white-space: nowrap;\n}\n.dni-treeview {\n    white-space: nowrap;\n}\n.dni-treeview td {\n    vertical-align: top;\n    text-align: start;\n}\ndetails.dni-treeview {\n    padding-left: 1em;\n}\ntable td {\n    text-align: start;\n}\ntable tr { \n    vertical-align: top; \n    margin: 0em 0px;\n}\ntable tr td pre \n{ \n    vertical-align: top !important; \n    margin: 0em 0px !important;\n} \ntable th {\n    text-align: start;\n}\n\n\nMost people think since functional programing discourages mutation, that means tying their hands and being useless. However, there\u0027s a communication failure here. Functional programming is valuable, not because discourages mutation, but because it encourages structured programming and composability.\nThe above function contains one of those patterns that appear everywhere, and functional programming can help you to recognize and reuse it more than imperative programming. Let\u0027s take a look at the power function and how it allows to implement Fibonacci:\nlet rec power (f: \u0026#39;a -\u0026gt; \u0026#39;a) (initial: \u0026#39;a, n: int) =\n  if n = 0 then initial else power f (f initial, n - 1)\n\nlet fibonacci1 n = power (fun (a, b) -\u0026gt; (b, a \u002B b)) ((0, 1), n) |\u0026gt; fst\n\nNow you can see how fibonacci1 is verbose in those aspects essential to Fibonacci: the initial state and how it transitions to the next. The rest is left to the power function.\nAnother thing while loops help us to find are fixed points, i.e. for a function f a value c that holds f c = c. But this pattern can be disentangled from while loops as well:\nlet fixedPoint (f: \u0026#39;a -\u0026gt; \u0026#39;a) (initial: \u0026#39;a) =\n  let rec loop (prev: \u0026#39;a) (current: \u0026#39;a) =\n    if prev = current then prev else loop current (f current)\n\n  loop initial (f initial)\n\nEuclid\u0027s Algorithm for calculating the Greatest Common Divisor between two positive integers relies on finding a fixed point:\nlet gcd0 (a:int, b:int) =\n  let mutable x = a\n  let mutable y = b\n  while x \u0026lt;\u0026gt; y do\n    if x \u0026gt; y then x \u0026lt;- x - y else y \u0026lt;- y - x\n  \n  x\n\ngcd0 (12,8)\n\n4\n.dni-code-hint {\n    font-style: italic;\n    overflow: hidden;\n    white-space: nowrap;\n}\n.dni-treeview {\n    white-space: nowrap;\n}\n.dni-treeview td {\n    vertical-align: top;\n    text-align: start;\n}\ndetails.dni-treeview {\n    padding-left: 1em;\n}\ntable td {\n    text-align: start;\n}\ntable tr { \n    vertical-align: top; \n    margin: 0em 0px;\n}\ntable tr td pre \n{ \n    vertical-align: top !important; \n    margin: 0em 0px !important;\n} \ntable th {\n    text-align: start;\n}\n\n\nNow, relying on our fixedPoint function we get:\nlet step (x: int, y: int) =\n  if x \u0026gt; y then x - y, y\n  else if x \u0026lt; y then x, y - x\n  else x, y\n\nlet gcd1 = fixedPoint step \u0026gt;\u0026gt; fst\n\ngcd1 (12, 8)\n\n4\n.dni-code-hint {\n    font-style: italic;\n    overflow: hidden;\n    white-space: nowrap;\n}\n.dni-treeview {\n    white-space: nowrap;\n}\n.dni-treeview td {\n    vertical-align: top;\n    text-align: start;\n}\ndetails.dni-treeview {\n    padding-left: 1em;\n}\ntable td {\n    text-align: start;\n}\ntable tr { \n    vertical-align: top; \n    margin: 0em 0px;\n}\ntable tr td pre \n{ \n    vertical-align: top !important; \n    margin: 0em 0px !important;\n} \ntable th {\n    text-align: start;\n}\n\n\nThis time we discover there\u0027s a fixed point when dividing successive elements of the Fibonacci sequence. That number is known as Golden Ratio.\nlet fibonacci = Seq.unfold (fun (a, b) -\u0026gt; Some(a, (b, a \u002B b))) (0, 1)\n\nlet fixedPointSeq (xs: \u0026#39;a seq) = xs |\u0026gt; Seq.pairwise |\u0026gt; Seq.find (fun (a,b) -\u0026gt; a = b) |\u0026gt; fst\n\nfibonacci |\u0026gt; Seq.pairwise |\u0026gt; Seq.map (fun (a,b) -\u0026gt; double b / double a ) |\u0026gt; fixedPointSeq\n\n1.618033988749895\n.dni-code-hint {\n    font-style: italic;\n    overflow: hidden;\n    white-space: nowrap;\n}\n.dni-treeview {\n    white-space: nowrap;\n}\n.dni-treeview td {\n    vertical-align: top;\n    text-align: start;\n}\ndetails.dni-treeview {\n    padding-left: 1em;\n}\ntable td {\n    text-align: start;\n}\ntable tr { \n    vertical-align: top; \n    margin: 0em 0px;\n}\ntable tr td pre \n{ \n    vertical-align: top !important; \n    margin: 0em 0px !important;\n} \ntable th {\n    text-align: start;\n}\n\n\nFunctions power and fixedPoint are inspired by the power operator in APL (\u2363)\n","headings":["Fixed points"],"type":"content"},{"uri":"/lamg.github.io/queue.html","title":"Queue\n","content":"Queue\nA queue is data structure that stores a sequence of elements, while supporting two basic operations: enqueue and dequeue\nLet\u0027s visualize how it works:\n [0; 1; 2]\n= { enqueue 42 }\n [0; 1; 2; 42]\n\n [0; 1; 2]\n= { dequeue }\n 0, [1; 2]\n\nFirst restriction: rely on inmutable data structures\n\nUsing a list we can rely on the operator :: for dequeueing, since pattern matching x::xs O(1)\nHowever this means for enqueuing we need to do xs @ [x] which is O(n), where n = xs.Length\n\nSolution:\n\nrely on :: for both enqueue and dequeue, since the operation x::xs is O(1)\nWe can use two lists one enqueueing and one for dequeueing, front and rear respectively\nFor dequeueing elements we do the pattern match x::xs on front getting in x the expected element, while in xs the new value for front.\nFor enqueueing we repleace rear by x::rear, however this list ends up reversed according the expected order when dequeueing, since x is its first element and should be the last dequeued.\nAt some point the dequeue operation will leave empty the front list. When that happens we can take rear, reverse it and use it as the new front while the new rear is an empty list.\n\ntype Queue\u0026lt;\u0026#39;a\u0026gt; = { front: \u0026#39;a list; rear: \u0026#39;a list }\n\nlet enqueue (q: Queue\u0026lt;\u0026#39;a\u0026gt;) (x: \u0026#39;a) = { q with rear = x :: q.rear }\n\nlet dequeue (q: Queue\u0026lt;\u0026#39;a\u0026gt;) =\n  match q.front, List.rev q.rear with\n  | [], [] -\u0026gt; None\n  | [], x :: xs -\u0026gt; Some(x, { front = xs; rear = [] })\n  | x :: xs, _ -\u0026gt; Some(x, { q with front = xs })\n\nlet rec queueToSeq (q: Queue\u0026lt;\u0026#39;a\u0026gt;) =\n  seq {\n    match dequeue q with\n    | None -\u0026gt; ()\n    | Some(x, nq) -\u0026gt;\n      yield x\n      yield! queueToSeq nq\n  }\n\nLet\u0027s make a simple test for our algorithm:\nlet xs = Seq.init 10 id |\u0026gt; Seq.toList\nlet q = xs |\u0026gt; Seq.fold (fun q x -\u0026gt; enqueue q x) {front = []; rear = []}\nlet ys = queueToSeq q |\u0026gt; Seq.toList\nList.zip xs ys |\u0026gt; List.forall (fun (x, y) -\u0026gt; x = y)\n\nTrue\n.dni-code-hint {\n    font-style: italic;\n    overflow: hidden;\n    white-space: nowrap;\n}\n.dni-treeview {\n    white-space: nowrap;\n}\n.dni-treeview td {\n    vertical-align: top;\n    text-align: start;\n}\ndetails.dni-treeview {\n    padding-left: 1em;\n}\ntable td {\n    text-align: start;\n}\ntable tr { \n    vertical-align: top; \n    margin: 0em 0px;\n}\ntable tr td pre \n{ \n    vertical-align: top !important; \n    margin: 0em 0px !important;\n} \ntable th {\n    text-align: start;\n}\n\n\nNotice that in the current implementation of Microsoft\u0027s F# compiler, the following pattern match\nmatch q.front, List.rev q.rear with\n| [], [] -\u0026gt; ...\n| [], x :: xs -\u0026gt; ...\n| x :: xs, _ -\u0026gt; ...\n\nevaluates List.rev q.rear always before matching any branch. This means that the code could easily be made more efficient. However, I think it makes no sense to evaluate such an expression until after q.front has been matched, since in some situations this would be sufficient to decide which branch to take. For this reason, I prefer to present the algorithm as it is, and leave it to the reader to optimise it if they think it is necessary.\n","headings":["Queue","First restriction: rely on inmutable data structures","Solution:"],"type":"content"},{"uri":"/lamg.github.io/README.html","title":"Structured programming in F#\n","content":"Structured programming in F#\nOne of the things I enjoyed when discovering for the first time functional programming, was how it reveals\npatterns that traditional imperative programming hides. I was delighted to discover how implementing Breadth-First Search with the sort of restrictions we  expect from functional programming, also reveals hidden patterns.\nAnother surprise is that F# is a great candidate to explore functional data structures, which seem could be\na good update to the excellent work by Chris Okasaki\n\nBreadth-First Search\nQueue\nPattern matching nesting reduction\nFixed points\nException vs Result\n\n","headings":["Structured programming in F#"],"type":"content"},{"uri":"/lamg.github.io/pattern_matching_nesting_reduction.html","title":"Pattern matching nesting reduction\n","content":"Pattern matching nesting reduction\nWe have to implement the function classify with the following signature\ntype Status = Started | NotStarted | Completed\nlet classify (first: \u0026#39;a option) (last: \u0026#39;b option): Status = raise \u0026lt;| NotImplementedException()\n\nA common implementation would be the following:\nlet classify (first: \u0026#39;t option) (last: \u0026#39;u option) =\n  match first with\n  | Some _ -\u0026gt;\n    match last with\n    | Some _ -\u0026gt; Completed\n    | _ -\u0026gt; Started\n  | _ -\u0026gt; NotStarted\n\n[classify (Some 0) None; classify None (Some \u0026quot;x\u0026quot;); classify (Some 0) (Some \u0026quot;y\u0026quot;)]\n\nHowever, we can make a trade of nested pattern matching by a more complex data structure and a simpler pattern match:\nlet classify (first: \u0026#39;t option) (last: \u0026#39;u option) =\n  match first, last with\n  | Some _, Some _ -\u0026gt; Completed\n  | Some _, _ -\u0026gt; Started \n  | _ -\u0026gt; NotStarted\n\n[classify (Some 0) None; classify None (Some \u0026quot;x\u0026quot;); classify (Some 0) (Some \u0026quot;y\u0026quot;)]\n\nThe trick can be generalized if the following conditions are true\n- you have a nested pattern matching\n- the decision to take one branch or another depends only on pure values (no implicit state can change the decision)\nThen what we do is encoding in each branch the precondition necessary to produce each value in the original code. Let\u0027s anotate the previous example with such preconditions:\nlet classify (first: \u0026#39;t option) (last: \u0026#39;u option) =\n  match first with\n  | Some _ -\u0026gt;\n    match last with\n    | Some _ -\u0026gt;\n        // precondition: first.IsSome \u0026amp;\u0026amp; last.IsSome \n        Completed\n    | _ -\u0026gt;\n        // precondition: first.IsSome \u0026amp;\u0026amp; last.IsNone\n        Started\n  | _ -\u0026gt; \n    // precondition: first.IsNone\n    NotStarted\n\nNow you can see we only use the arrow -\u0026gt; when we match the exact condition that produces a value, and by following that principle we continue by creating a more complex structure to match, but we reduce the nested matches. The inspiration for this trick comes from Dijkstra\u0027s Guarded Command Language and Programming: The Derivation of Algorithms.\n","headings":["Pattern matching nesting reduction"],"type":"content"},{"uri":"/lamg.github.io/exception_vs_result.html","title":"Exception vs Result\n","content":"Exception vs Result\nAn exception happens after the violation of a precondition in our code. For example, in the code below y \u2260 0 is a precondition:\nlet x = stdin.ReadLine() |\u0026gt; int\nlet y = stdin.ReadLine() |\u0026gt; int\nlet r = x / y\nprintfn $\u0026quot;{x} / {y} = {r}\u0026quot;\n\nWe also know that in some situations it is better to treat the error as any other value than to throw an exception. So the question is, do we represent an error as a value or do we throw an exception?\nMy way of answering such dilemma is: can the abnormal situation be followed by operations in the same domain where it occurred or do we have to leave it?\nIn the example above after y = 0 there is no calculation allowing us to continue, it\u0027s the user who should know that y = 0 is not part of the domain of the operation. So it makes sense to catch the exception or if possible to never let such value enter that scope.\nSometimes we discover that our domain can be enriched with values representing abnormal situations, and that way we can continue operating within it. However, in some cases, adding a Result type doesn\u0027t change the fact the only thing we can do is leaving one or more scopes.\nIn those instances an exception is more appropriate because adding Result is only making more cumbersome our way out.\nOriginally posted on 2023/10/21 on Twitter\n","headings":["Exception vs Result"],"type":"content"},{"uri":"/lamg.github.io/bfs.html","title":"Revisiting BFS\n","content":"Revisiting BFS\nWhat is BFS\n\nBFS is a way of creating a sequence with all elements of a tree or graph\nIt consists in returning all elements with depth N, and then the elements with depth N\u002B1, until elements are over\nThe initial depth is 0\n\nThe common solution\n\nThe typical imperative implementation of BFS relies on a queue\nThe current element is pulled out of the queue, and its children are pushed in\n\nQuestioning the common solution\n\nThe relation between the queue, the way it works, and the BFS definition is not clear\nIs it possible to rely on pure functional data structures instead of mutation?\n\nFirst discovery\n\nThe queue in the imperative solution is divided in two parts: | children with depth N | children with depth N\u002B1|\nNow is clear what we do is returning children in the same level, and meanwhile conveniently recording and postponing children in the next level\nWe could have separate lists for children in different levels\nWe could annotate each level with its corresponding number, so we can filter later which levels do we need\n\nFirst restriction\n\n\nBFS in a graph requires to mark which nodes we have visited, while in a tree we don\u0027t, \nsince in the latter case there\u0027s no possibility to create an infinite loop\n\n\nthe function returning the children can take care independently of marking or not, depending on wether is a graph or a tree.\nThat way the BFS implementation can be delivered from that concern, and thus is cleaner and more general.\n\n\nSecond restriction\n\n\nIn functional programming instead of representing mutation in a block of code, we create a new instance of it\nsubstituting the old value by the new one.\n\nYou can see the difference in comparing the following two blocks of code:\n\nusing System;\n\nint[] MoveFromTo() {\n    var from = new List\u0026lt;int\u0026gt;(new int[] { 1, 2, 3 });\n    var to = new List\u0026lt;int\u0026gt;();\n    while (from.Count \u0026gt; 0) {\n        to.Add(from[0]);\n        from.RemoveAt(0);\n    }\n    return to.ToArray();\n}\n\nlet moveFromTo () =\n    let rec loop from to\u0026#39; =\n        match from with\n        | [] -\u0026gt; (from, to\u0026#39;)\n        | x::xs -\u0026gt; \n            // here we replace to\u0026#39; by x::to\u0026#39; in a new instance of loop\n            loop xs (x::to\u0026#39;)\n    \n    let from = [1; 2 ;3]\n    let to\u0026#39; = []\n    loop from to\u0026#39;\n\nHow the implementation works\n\nGetChildren is our generic way of getting children from whatever nested structure we are dealing with (trees, graphs)\nAlong with the list of children it returns and instance of itself. This is needed because is the functional way of updating the collection where we store visited nodes.\nOur List.fold processes each element x in level. In each iteration of it needs an updated GetChildren instance, which stores the visited nodes. You can see in the function passed as parameter how xs is replaced by xs @ ys and gc for newGc, for the next iteration.\nOnce the fold finishes we have in nextLevel all the nodes of level n\u002B1. Since nextLevel is the replacement for level and our bfs function operates on particular level instances, then is time to call bfs with nextLevel. In case nextLevel is empty, we return the empty sequence and stop the recursive calls.\n\ntype GetChildren\u0026lt;\u0026#39;a\u0026gt; = { get: \u0026#39;a -\u0026gt; (GetChildren\u0026lt;\u0026#39;a\u0026gt; * \u0026#39;a list) }\n\nlet rec bfs (gc: GetChildren\u0026lt;\u0026#39;a\u0026gt;, n: int, level: \u0026#39;a list) =\n  seq {\n    yield (n, level)\n\n    let nextLevel =\n      level\n      |\u0026gt; List.fold\n        (fun (gc, xs) x -\u0026gt;\n          let newGc, ys = gc.get x\n          (newGc, xs @ ys)\n        )\n\n        (gc, []) // initial state\n        \n    yield! \n        match nextLevel with\n        | _, [] -\u0026gt; Seq.empty\n        | (chl, nl) -\u0026gt; bfs  (chl, n\u002B1, nl)\n  }\n\nTesting the implementation with a graph\ntype Graph\u0026lt;\u0026#39;a when \u0026#39;a: comparison\u0026gt; = Map\u0026lt;\u0026#39;a, List\u0026lt;\u0026#39;a\u0026gt;\u0026gt;\n\nlet graphChildren (g: Graph\u0026lt;\u0026#39;a\u0026gt;) =\n  let rec children visited =\n    { get =\n        fun x -\u0026gt;\n          if Set.contains x visited then\n            // x is already visited, no need to mark it as visited\n            (children visited, [])\n          else\n            let newChildren = Set.add x visited |\u0026gt; children\n\n            match Map.tryFind x g with\n            | Some xs -\u0026gt; (newChildren, xs)\n            | None -\u0026gt; (newChildren, []) }\n\n  children Set.empty\n\nlet g = Map [ 1, [ 2; 3; 4 ]; 2, [ 5; 6 ]; 3, [ 7; 8 ]; 4, [ 9; 10 ] ]\n\nbfs (graphChildren g, 0, [ 1 ]) |\u0026gt; Seq.iter (printfn \u0026quot;%A\u0026quot;)\n\n(0, [1])\n(1, [2; 3; 4])\n(2, [5; 6; 7; 8; 9; 10])\n\nTesting the implementation with a tree\nIn a tree by visiting a node there\u0027s no way of going back to it, since there are no cycles. Keeping that in mind,\nwe can rely on a sequence of children to be consumed by bfs. As long as we put children in the order bfs expects them, the implementation will be correct.\nExample:\nWe know if bfs gets the children of node X, then after that it will ask for children of node X\u002B1, where X and X\u002B1 are consecutive nodes in the same level.\ntype Tree\u0026lt;\u0026#39;a\u0026gt; = Node of \u0026#39;a * Tree\u0026lt;\u0026#39;a\u0026gt; list\n\nlet rec childrenSeq (Node(_, xs)) =\n  seq {\n    match xs with\n    | [] -\u0026gt; ()\n    | _ -\u0026gt;\n      let nodeValues = xs |\u0026gt; List.map (fun (Node(x, _)) -\u0026gt; x)\n      yield nodeValues\n\n    for x in xs do\n      yield! childrenSeq x\n  }\n\nlet treeChildren (t: Tree\u0026lt;\u0026#39;a\u0026gt;) =\n  let chs = childrenSeq t |\u0026gt; Seq.toList\n\n  let rec loop (chs: (\u0026#39;a list) list) =\n    { get =\n        fun _ -\u0026gt;\n          match chs with\n          | [] -\u0026gt; (loop [], [])\n          | head::tail -\u0026gt; (loop tail, head) }\n\n  loop chs\n\nlet t =\n  Node(\n    1,\n    [ Node(2, [ Node(5, []); Node(6, []) ])\n      Node(3, [ Node(7, []); Node(8, []) ])\n      Node(4, [ Node(9, []); Node(10, []) ]) ]\n  )\n\nbfs (treeChildren t, 0, [ 1 ]) |\u0026gt; Seq.iter (printfn \u0026quot;%A\u0026quot;)\n\n(0, [1])\n(1, [2; 3; 4])\n(2, [5; 6; 7; 8; 9; 10])\n\n","headings":["Revisiting BFS","What is BFS","The common solution","Questioning the common solution","First discovery","First restriction","Second restriction","How the implementation works","Testing the implementation with a graph","Testing the implementation with a tree"],"type":"content"},{"uri":"/lamg.github.io/index.html","title":"Structured programming in F#\n","content":"Structured programming in F#\nOne of the things I enjoyed when discovering for the first time functional programming, was how it reveals\npatterns that traditional imperative programming hides. I was delighted to discover how implementing Breadth-First Search with the sort of restrictions we  expect from functional programming, also reveals hidden patterns.\nAnother surprise is that F# is a great candidate to explore functional data structures, which seem could be\na good update to the excellent work by Chris Okasaki\n\nBreadth-First Search\nQueue\nPattern matching nesting reduction\nFixed points\nException vs Result\n\n","headings":["Structured programming in F#"],"type":"content"}]